# BACKEND AUTO ASSIGNMENT & CANCEL LOGIC

## Ng·ªØ c·∫£nh
Document n√†y chi ti·∫øt ho√° logic Backend cho vi·ªác auto assignment doctor v√† workflow h·ªßy l·ªãch h·∫πn ph·ª©c t·∫°p.

**Ng√†y t·∫°o:** 2025-01-25  
**Tr·∫°ng th√°i:** üìã Planning Phase  
**Scope:** Backend Services & Controllers  

---

## ‚ú® **STATUS LOGIC ƒê·ªÄ XU·∫§T**

### üéØ **Status Design Philosophy:**
- ‚ùå **Lo·∫°i b·ªè:** `pending`, `paid`, `confirmed` (redundant steps)
- ‚úÖ **ƒê∆°n gi·∫£n ho√°:** 4 core states cho Appointments, 5 cho Consultations
- ‚úÖ **Auto-confirm:** Payment success ‚Üí immediately `scheduled`

### üìä **Status Enum ƒê·ªÅ Xu·∫•t:**

```typescript
// ‚úÖ APPOINTMENTS STATUS (4 states)
type AppointmentStatus = 
  | 'pending_payment'  // Ch·ªù thanh to√°n
  | 'scheduled'        // ƒê√£ thanh to√°n, s·∫µn s√†ng th·ª±c hi·ªán
  | 'completed'        // ƒê√£ ho√†n th√†nh  
  | 'cancelled'        // H·ªßy b·ªè

// ‚úÖ CONSULTATIONS STATUS (5 states - includes 'consulting')  
type ConsultationStatus =
  | 'pending_payment'  // Ch·ªù thanh to√°n
  | 'scheduled'        // ƒê√£ thanh to√°n, s·∫µn s√†ng t∆∞ v·∫•n
  | 'consulting'       // ƒêang trong session t∆∞ v·∫•n tr·ª±c tuy·∫øn
  | 'completed'        // ƒê√£ ho√†n th√†nh t∆∞ v·∫•n
  | 'cancelled'        // H·ªßy b·ªè
```

### üîÑ **Workflow Logic:**

```
üìÖ CUSTOMER BOOKS APPOINTMENT
    ‚Üì
‚è≥ Status: 'pending_payment' 
    ‚Üì
üí≥ PAYMENT SUCCESS ‚Üí Status: 'scheduled' (b·ªè qua doctor confirm)
    ‚Üì
üè• APPOINTMENT EXECUTION ‚Üí Status: 'completed'
```

---

## AUTO ASSIGNMENT LOGIC - CHI TI·∫æT

### üéØ **Thu·∫≠t to√°n Auto Assignment M·ªõi**

#### **B∆∞·ªõc 1: T√¨m Slot G·∫ßn Nh·∫•t**
```typescript
// Function: findNearestAvailableTimeSlots()
// Input: currentDate
// Output: Array of time slots sorted by proximity
[
  {
    date: "2025-01-26",
    slotTime: "08:00-09:00",
    availableDoctors: [...]
  },
  {
    date: "2025-01-26", 
    slotTime: "09:00-10:00",
    availableDoctors: [...]
  },
  ...
]
```

#### **B∆∞·ªõc 2: T·∫°o Doctor Priority Filter**
```typescript
// Function: createDoctorPriorityFilter()
// Input: doctors[]
// Output: Array of {doctorId, bookedSlotCount} sorted ascending

interface DoctorPriority {
  doctorId: string;
  doctorName: string;
  bookedSlotCount: number;
  availableInSlot: boolean;
}

// Example output:
[
  { doctorId: "dr001", doctorName: "BS A", bookedSlotCount: 2 },
  { doctorId: "dr002", doctorName: "BS B", bookedSlotCount: 3 },
  { doctorId: "dr003", doctorName: "BS C", bookedSlotCount: 5 },
]
```

#### **B∆∞·ªõc 3: Smart Assignment v·ªõi Priority**
```typescript
// Function: smartAssignWithPriority()
// Logic:
1. L·∫•y slot g·∫ßn nh·∫•t
2. T√¨m doctors available trong slot ƒë√≥
3. S·∫Øp x·∫øp doctors theo bookedSlotCount (ascending)
4. Assign cho doctor c√≥ priority cao nh·∫•t (√≠t slot nh·∫•t)
5. N·∫øu slot ƒë·∫ßy ‚Üí chuy·ªÉn sang slot ti·∫øp theo
6. Repeat cho ƒë·∫øn khi t√¨m ƒë∆∞·ª£c assignment ho·∫∑c h·∫øt slot
```

### üîß **Implementation Details**

#### **Core Function: intelligentAutoAssignment()**
```typescript
export const intelligentAutoAssignment = async (): Promise<AssignmentResult> => {
  try {
    // Step 1: Get nearest time slots (sorted by date+time)
    const nearestSlots = await findNearestAvailableTimeSlots();
    
    // Step 2: Create doctor priority map (sorted by booked count)
    const doctorPriorities = await createDoctorPriorityMap();
    
    // Step 3: Iterate through slots to find optimal assignment
    for (const slot of nearestSlots) {
      const assignment = await tryAssignInSlot(slot, doctorPriorities);
      if (assignment.success) {
        return assignment;
      }
    }
    
    throw new Error('Kh√¥ng t√¨m th·∫•y slot kh·∫£ d·ª•ng');
  } catch (error) {
    console.error('‚ùå Intelligent auto assignment failed:', error);
    throw error;
  }
};

// Helper function: tryAssignInSlot()
const tryAssignInSlot = async (
  slot: TimeSlot, 
  doctorPriorities: DoctorPriority[]
): Promise<AssignmentResult> => {
  
  // Filter doctors available in this specific slot
  const availableDoctors = doctorPriorities.filter(doctor => 
    slot.availableDoctors.some(d => d.doctorId === doctor.doctorId)
  );
  
  if (availableDoctors.length === 0) {
    return { success: false, reason: 'No doctors available in slot' };
  }
  
  // Sort by bookedSlotCount (ascending) - priority cho doctor √≠t vi·ªác nh·∫•t
  const sortedDoctors = availableDoctors.sort((a, b) => 
    a.bookedSlotCount - b.bookedSlotCount
  );
  
  // Assign to highest priority doctor (lowest booked count)
  const selectedDoctor = sortedDoctors[0];
  
  return {
    success: true,
    doctorId: selectedDoctor.doctorId,
    doctorName: selectedDoctor.doctorName,
    appointmentDate: slot.date,
    appointmentSlot: slot.slotTime,
    slotId: slot.slotId,
    priority: selectedDoctor.bookedSlotCount
  };
};
```

---

## STATUS MANAGEMENT - S·ª¨A L·∫†I

### üîÑ **Status Update Logic:**

#### **Payment Success Flow:**
```typescript
// ‚úÖ S·ª¨A updatePaymentStatus() 
export const updatePaymentStatus = async (id: string, paymentSuccess: boolean) => {
  try {
    if (paymentSuccess) {
      // Chuy·ªÉn t·ª´ 'pending_payment' ‚Üí 'scheduled' (b·ªè qua doctor confirm)
      const updatedRecord = await updateBothTables(id, {
        status: 'scheduled'
      });
      
      console.log(`‚úÖ Payment confirmed for ${id} - Status: scheduled`);
      return updatedRecord;
    } else {
      // Payment failed
      return { status: 'cancelled' };
    }
  } catch (error) {
    console.error('‚ùå Payment status update failed:', error);
    throw error;
  }
};
```

---

## CANCEL LOGIC - KH√ÅC NHAU THEO LO·∫†I D·ªäCH V·ª§

### üìã **CANCELLATION RULES SUMMARY:**

#### **üè• APPOINTMENTS (L·ªãch h·∫πn kh√°m b·ªánh):**
- ‚úÖ **Doctor cancel rule:** 72h rule - ch·ªâ cancel ƒë∆∞·ª£c TR∆Ø·ªöC 72 gi·ªù
- ‚úÖ **Status requirement:** Ch·ªâ cancel ƒë∆∞·ª£c khi status = `scheduled` ho·∫∑c `consulting`
- ‚úÖ **Outcome:** Cancel ho√†n to√†n, kh√¥ng auto re-assign

#### **üí¨ CONSULTATIONS (T∆∞ v·∫•n tr·ª±c tuy·∫øn):**
- ‚úÖ **Doctor cancel rule:** KH√îNG c√≥ 72h rule - doctor c√≥ th·ªÉ cancel b·∫•t k·ª≥ l√∫c n√†o
- ‚úÖ **Status requirement:** Cancel ƒë∆∞·ª£c t·ª´ `pending_payment`, `scheduled`, `consulting`
- ‚úÖ **KH√îNG cancel ƒë∆∞·ª£c:** `completed`, `cancelled`
- ‚úÖ **Outcome:** T·ª∞ ƒê·ªòNG re-assign b√°c sƒ© kh√°c cho b·ªánh nh√¢n

---

### üö´ **UPDATED: Appointment Cancel Logic (72h Rule)**

#### **Function: cancelAppointmentByDoctor() - ‚úÖ LOGIC CONFIRMED**
```typescript
export const cancelAppointmentByDoctor = async (
  appointmentId: string, 
  doctorId: string,
  reason: string
): Promise<CancelResult> => {
  try {
    // Step 1: Validate 72h rule
    const appointment = await Appointments.findById(appointmentId);
    const canCancel = validateCancelDeadline(appointment.appointmentDate, appointment.appointmentTime);
    
    if (!canCancel) {
      throw new Error('Kh√¥ng th·ªÉ h·ªßy l·ªãch h·∫πn d∆∞·ªõi 72 ti·∫øng tr∆∞·ªõc gi·ªù h·∫πn');
    }
    
    // Step 2: Set current slot to ABSENT
    await setSlotStatus(doctorId, appointment.slotId, 'Absent');
    
    // Step 3: Cancel appointment completely (no customer choice for simplicity)
    await Appointments.findByIdAndUpdate(appointmentId, {
      status: 'cancelled',
      doctorCancelReason: reason,
      cancelledAt: new Date(),
      cancelledByDoctor: true
    });
    
    return {
      success: true,
      message: 'L·ªãch h·∫πn ƒë√£ ƒë∆∞·ª£c h·ªßy th√†nh c√¥ng.',
      cancelled: true
    };
    
  } catch (error) {
    console.error('‚ùå Appointment cancellation failed:', error);
    throw error;
  }
};

// Helper: Validate 72h rule
const validateCancelDeadline = (appointmentDate: string, appointmentTime: string): boolean => {
  const now = new Date();
  const appointmentDateTime = new Date(`${appointmentDate} ${appointmentTime}`);
  const deadline = new Date(now.getTime() + (72 * 60 * 60 * 1000)); // +72h
  
  return deadline <= appointmentDateTime;
};
```

### ü©∫ **UPDATED: Consultation Transfer Logic (New Requirement)**

#### **Function: transferConsultationByDoctor() - ‚ùå NEEDS NEW IMPLEMENTATION**
```typescript
export const cancelConsultationByDoctor = async (
  consultationId: string,
  doctorId: string, 
  reason: string
): Promise<CancelResult> => {
  try {
    const consultation = await DoctorQA.findById(consultationId);
    
    // Step 1: Set current slot to ABSENT
    await setSlotStatus(doctorId, consultation.slotId, 'Absent');
    
    // Step 2: Auto re-assign immediately (no customer choice)
    const newAssignment = await intelligentAutoAssignment();
    
    // Step 3: Update consultation with new assignment
    await DoctorQA.findByIdAndUpdate(consultationId, {
      doctorId: newAssignment.doctorId,
      appointmentDate: newAssignment.appointmentDate,
      appointmentSlot: newAssignment.appointmentSlot,
      slotId: newAssignment.slotId,
      status: 'scheduled', // Keep scheduled
      reassignedAt: new Date(),
      reassignReason: reason
    });
    
    // Step 4: Book new slot
    await setSlotStatus(newAssignment.doctorId, newAssignment.slotId, 'Booked');
    
    // Step 5: Notify customer about the change
    await sendReassignmentNotification(consultation.userId, newAssignment);
    
    return {
      success: true,
      message: 'T∆∞ v·∫•n ƒë√£ ƒë∆∞·ª£c chuy·ªÉn cho b√°c sƒ© kh√°c',
      newAssignment
    };
    
  } catch (error) {
    console.error('‚ùå Consultation cancellation failed:', error);
    throw error;
  }
};
```

---

## SLOT MANAGEMENT - ABSENT STATUS

### üé∞ **Slot Status Management**

#### **Slot Status Types:**
```typescript
type SlotStatus = 'Free' | 'Booked' | 'Absent';

// 'Free' - Available for booking
// 'Booked' - Booked by customer  
// 'Absent' - Doctor cancelled/unavailable (audit trail)
```

#### **Function: setSlotStatus()**
```typescript
export const setSlotStatus = async (
  doctorId: string, 
  slotId: string, 
  newStatus: SlotStatus,
  metadata?: any
) => {
  try {
    const updateData: any = {
      'weekSchedule.$.slots.$[slot].status': newStatus,
      'weekSchedule.$.slots.$[slot].lastUpdated': new Date()
    };
    
    // Add metadata for audit trail
    if (metadata) {
      updateData['weekSchedule.$.slots.$[slot].metadata'] = metadata;
    }
    
    // Special handling for different statuses
    if (newStatus === 'Booked') {
      updateData['weekSchedule.$.slots.$[slot].bookedAt'] = new Date();
    } else if (newStatus === 'Absent') {
      updateData['weekSchedule.$.slots.$[slot].absentAt'] = new Date();
      updateData['weekSchedule.$.slots.$[slot].absentReason'] = metadata?.reason || 'Doctor cancelled';
    } else if (newStatus === 'Free') {
      // Clear booking/absent metadata
      updateData['$unset'] = {
        'weekSchedule.$.slots.$[slot].bookedAt': 1,
        'weekSchedule.$.slots.$[slot].absentAt': 1,
        'weekSchedule.$.slots.$[slot].absentReason': 1,
        'weekSchedule.$.slots.$[slot].metadata': 1
      };
    }
    
    const result = await DoctorSchedules.updateOne(
      { 
        doctorId: new mongoose.Types.ObjectId(doctorId),
        'weekSchedule.slots._id': new mongoose.Types.ObjectId(slotId)
      },
      updateData,
      {
        arrayFilters: [
          { 'slot._id': new mongoose.Types.ObjectId(slotId) }
        ]
      }
    );
    
    console.log(`‚úÖ Slot ${slotId} status updated to ${newStatus}`);
    return result;
    
  } catch (error) {
    console.error('‚ùå Slot status update failed:', error);
    throw error;
  }
};
```

---

## API ENDPOINTS REQUIRED

### üõ† **New Controller Functions**

#### **Auto Assignment Endpoints:**
```typescript
// POST /api/appointments/auto-assign
export const triggerAutoAssignment = async (req: Request, res: Response) => {
  const assignment = await intelligentAutoAssignment();
  res.json({ success: true, assignment });
};

// GET /api/doctors/priority-list
export const getDoctorPriorityList = async (req: Request, res: Response) => {
  const priorities = await createDoctorPriorityMap();
  res.json({ success: true, data: priorities });
};
```

#### **Cancel Management Endpoints:**
```typescript
// POST /api/appointments/:id/cancel-by-doctor  
export const cancelAppointmentByDoctorEndpoint = async (req: Request, res: Response) => {
  const { id } = req.params;
  const { reason } = req.body;
  const doctorId = req.user.doctorId; // from auth middleware
  
  const result = await cancelAppointmentByDoctor(id, doctorId, reason);
  res.json(result);
};

// POST /api/consultations/:id/cancel-by-doctor
export const cancelConsultationByDoctorEndpoint = async (req: Request, res: Response) => {
  const { id } = req.params;
  const { reason } = req.body;
  const doctorId = req.user.doctorId;
  
  const result = await cancelConsultationByDoctor(id, doctorId, reason);
  res.json(result);
};

// POST /api/customer-choice/:id/respond
export const respondToCustomerChoice = async (req: Request, res: Response) => {
  const { id } = req.params;
  const { choice } = req.body; // 'choose_new_doctor' | 'cancel_appointment'
  
  const result = await handleCustomerChoice(id, choice);
  res.json(result);
};
```

---

## DATABASE SCHEMA UPDATES

### üóÑÔ∏è **Required Schema Changes**

#### **CustomerChoice Model (New):**
```typescript
const CustomerChoiceSchema = new mongoose.Schema({
  appointmentId: { type: mongoose.Schema.Types.ObjectId, ref: 'Appointments', required: true },
  customerId: { type: mongoose.Schema.Types.ObjectId, ref: 'Users', required: true },
  doctorCancelReason: { type: String, required: true },
  customerChoice: { 
    type: String, 
    enum: ['choose_new_doctor', 'cancel_appointment'],
    default: null 
  },
  chosenAt: { type: Date, default: null },
  status: { 
    type: String, 
    enum: ['pending', 'completed'], 
    default: 'pending' 
  }
}, { timestamps: true });
```

#### **Appointments Schema Updates:**
```typescript
// Add new fields to existing Appointments model:
{
  autoConfirmed: { type: Boolean, default: false },
  confirmedAt: { type: Date },
  reassignedAt: { type: Date },
  doctorCancelReason: { type: String },
  customerChoiceId: { type: mongoose.Schema.Types.ObjectId, ref: 'CustomerChoice' }
}
```

#### **DoctorSchedules Slot Updates:**
```typescript
// Update TimeSlots schema:
{
  slotTime: String,
  status: { 
    type: String, 
    enum: ['Free', 'Booked', 'Absent'], 
    default: 'Free' 
  },
  bookedAt: Date,
  absentAt: Date,
  absentReason: String,
  lastUpdated: { type: Date, default: Date.now },
  metadata: mongoose.Schema.Types.Mixed // For audit trail
}
```

---

## TESTING STRATEGY

### üß™ **Test Cases Required**

#### **Auto Assignment Tests:**
```typescript
describe('Intelligent Auto Assignment', () => {
  test('Should assign to doctor with least booked slots', async () => {
    // Setup: 3 doctors with different booked counts
    // Expected: Choose doctor with lowest count
  });
  
  test('Should move to next slot if current slot is full', async () => {
    // Setup: First slot full, second slot available
    // Expected: Assign in second slot
  });
});
```

#### **Cancel Logic Tests:**
```typescript
describe('Appointment Cancellation', () => {
  test('Should allow cancel >72h before appointment', async () => {
    // Expected: Success with customer choice creation
  });
  
  test('Should reject cancel <72h before appointment', async () => {
    // Expected: Throw validation error
  });
});
```

---

## TIMELINE & MILESTONES

### üìÖ **Implementation Schedule**

#### **Week 1: Core Auto Assignment**
- [x] Frontend workflow updates (COMPLETED)
- [ ] intelligentAutoAssignment() function
- [ ] createDoctorPriorityMap() function  
- [ ] updatePaymentStatus() enhancement

#### **Week 2: Cancel Logic**
- [ ] cancelAppointmentByDoctor() with customer choice
- [ ] cancelConsultationByDoctor() with auto reassign
- [ ] setSlotStatus() with Absent support
- [ ] CustomerChoice model & endpoints

#### **Week 3: Integration & Testing**
- [ ] API endpoints setup
- [ ] Notification system
- [ ] Database migration
- [ ] Unit & integration tests

---

**Created by:** Backend Development Team  
**Last Updated:** 2025-01-25  
**Status:** üìã Ready for Implementation  
**Dependencies:** Frontend workflow completed ‚úÖ 